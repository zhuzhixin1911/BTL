#@title M√¥ ph·ªèng B·∫£o m·∫≠t Tin nh·∫Øn √Çm thanh

# ==============================================================================
# PH·∫¶N 1: C√ÄI ƒê·∫∂T V√Ä C·∫§U H√åNH
# ==============================================================================
# In ra th√¥ng b√°o cho ng∆∞·ªùi d√πng bi·∫øt qu√° tr√¨nh ƒëang b·∫Øt ƒë·∫ßu.
print("‚è≥ B∆∞·ªõc 1: C√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt...")
# S·ª≠ d·ª•ng pip ƒë·ªÉ c√†i ƒë·∫∑t c√°c th∆∞ vi·ªán Python c·∫ßn thi·∫øt m·ªôt c√°ch "√¢m th·∫ßm" (-q: quiet).
# - flask: Framework ƒë·ªÉ t·∫°o m√°y ch·ªß web.
# - pyngrok: Th∆∞ vi·ªán ƒë·ªÉ t·∫°o m·ªôt ƒë∆∞·ªùng h·∫ßm (tunnel) an to√†n t·ª´ m√°y ch·ªß c·ª•c b·ªô ra Internet b·∫±ng d·ªãch v·ª• ngrok.
# - cryptography: Th∆∞ vi·ªán c·ªët l√µi ƒë·ªÉ th·ª±c hi·ªán c√°c thao t√°c m√£ h√≥a.
!pip install flask pyngrok cryptography -q
print("‚úÖ C√†i ƒë·∫∑t ho√†n t·∫•t.")

print("üîë B∆∞·ªõc 2: C·∫•u h√¨nh token ngrok...")
# C·∫•u h√¨nh token x√°c th·ª±c cho ngrok.
# L·ªánh n√†y l∆∞u token v√†o file c·∫•u h√¨nh m·∫∑c ƒë·ªãnh c·ªßa ngrok.
!ngrok authtoken YOUR_TOKEN_HERE
print("‚úÖ Token ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh.")

# ==============================================================================
# PH·∫¶N 2: M√É NGU·ªíN ·ª®NG D·ª§NG (BACKEND + FRONTEND)
# ==============================================================================
# --- Nh·∫≠p c√°c th∆∞ vi·ªán v√† module c·∫ßn thi·∫øt cho Backend ---
import os  # Module ƒë·ªÉ t∆∞∆°ng t√°c v·ªõi h·ªá ƒëi·ªÅu h√†nh, d√πng ƒë·ªÉ t·∫°o s·ªë ng·∫´u nhi√™n an to√†n (os.urandom).
import base64  # Module ƒë·ªÉ m√£ h√≥a v√† gi·∫£i m√£ d·ªØ li·ªáu nh·ªã ph√¢n sang ƒë·ªãnh d·∫°ng vƒÉn b·∫£n an to√†n (Base64).
import json  # Module ƒë·ªÉ l√†m vi·ªác v·ªõi d·ªØ li·ªáu JSON.
import io  # Module ƒë·ªÉ l√†m vi·ªác v·ªõi c√°c lu·ªìng d·ªØ li·ªáu (stream) trong b·ªô nh·ªõ, d√πng ƒë·ªÉ t·∫°o file zip.
import zipfile  # Module ƒë·ªÉ t·∫°o v√† ƒë·ªçc c√°c file n√©n ZIP.
from flask import Flask, request, jsonify, render_template_string, Response  # C√°c th√†nh ph·∫ßn t·ª´ framework Flask.
from pyngrok import ngrok  # Module ƒë·ªÉ qu·∫£n l√Ω ƒë∆∞·ªùng h·∫ßm ngrok.
from cryptography.hazmat.primitives.asymmetric import rsa, padding as rsa_padding # C√°c th√†nh ph·∫ßn cho m√£ h√≥a b·∫•t ƒë·ªëi x·ª©ng RSA.
from cryptography.hazmat.primitives import hashes, serialization  # C√°c th√†nh ph·∫ßn cho h√†m bƒÉm (hashing) v√† tu·∫ßn t·ª± h√≥a kh√≥a (key serialization).
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  # C√°c th√†nh ph·∫ßn cho m√£ h√≥a ƒë·ªëi x·ª©ng AES.
from cryptography.hazmat.primitives.padding import PKCS7  # Module ƒë·ªÉ th√™m ph·∫ßn ƒë·ªám (padding) cho d·ªØ li·ªáu tr∆∞·ªõc khi m√£ h√≥a.

# Kh·ªüi t·∫°o ·ª©ng d·ª•ng Flask. `__name__` l√† m·ªôt bi·∫øn ƒë·∫∑c bi·ªát trong Python, gi√∫p Flask bi·∫øt v·ªã tr√≠ c·ªßa ·ª©ng d·ª•ng.
app = Flask(__name__)

# T·∫°o m·ªôt "b·ªô nh·ªõ ƒë·ªám" (cache) ƒë∆°n gi·∫£n d∆∞·ªõi d·∫°ng dictionary ƒë·ªÉ l∆∞u k·∫øt qu·∫£ x·ª≠ l√Ω cu·ªëi c√πng.
# Vi·ªác n√†y c·∫ßn thi·∫øt ƒë·ªÉ ch·ª©c nƒÉng t·∫£i xu·ªëng c√≥ th·ªÉ truy c·∫≠p v√†o d·ªØ li·ªáu ƒë√£ x·ª≠ l√Ω.
last_result_cache = {}

# --- Giao di·ªán (Frontend) ---
# To√†n b·ªô giao di·ªán ng∆∞·ªùi d√πng (HTML, CSS, JavaScript) ƒë∆∞·ª£c ch·ª©a trong m·ªôt chu·ªói ƒëa d√≤ng c·ªßa Python.
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ ph·ªèng B·∫£o m·∫≠t Tin nh·∫Øn √Çm thanh</title>
    <style>
        /* C√°c quy t·∫Øc CSS ƒë·ªÉ l√†m cho giao di·ªán tr√¥ng ƒë·∫πp m·∫Øt v√† chuy√™n nghi·ªáp. */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; line-height: 1.6; padding: 20px; background-color: #f4f7f9; color: #333; }
        .container { max-width: 1200px; margin: auto; background: white; padding: 25px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h1, h2 { color: #0056b3; border-bottom: 2px solid #eef; padding-bottom: 10px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 30px; } /* T·∫°o layout d·∫°ng l∆∞·ªõi 2 c·ªôt */
        .box { padding: 20px; border: 1px solid #ddd; border-radius: 5px; background-color: #fafafa; }
        textarea { width: 100%; height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 13px; box-sizing: border-box; }
        button { background-color: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px; margin-top: 10px; transition: background-color 0.3s; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #ccc; cursor: not-allowed; } /* Ki·ªÉu cho n√∫t b·ªã v√¥ hi·ªáu h√≥a */
        #stop-recording-btn { background-color: #dc3545; }
        #stop-recording-btn:hover { background-color: #c82333; }
        #download-btn { background-color: #28a745; display: none; } /* N√∫t download ban ƒë·∫ßu s·∫Ω ƒë∆∞·ª£c ·∫©n ƒëi */
        #download-btn:hover { background-color: #218838; }
        pre { background-color: #eef; padding: 15px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 13px; max-height: 300px; overflow-y: auto; }
        label { font-weight: bold; margin-bottom: 5px; display: block; }
        .full-width { grid-column: 1 / -1; } /* Ki·ªÉu cho ph·∫ßn t·ª≠ chi·∫øm tr·ªçn chi·ªÅu r·ªông c·ªßa grid */
        #recording-status { margin-top: 15px; font-weight: bold; color: #17a2b8; }
        #audio-playback-container { margin-top: 20px; display: none; } /* V√πng ch·ª©a tr√¨nh ph√°t audio ban ƒë·∫ßu ·∫©n ƒëi */
        audio { width: 100%; }
        .error-log { color: #dc3545; font-weight: bold; } /* Ki·ªÉu cho th√¥ng b√°o l·ªói */
    </style>
</head>
<body>
    <div class="container">
        <h1>M√¥ ph·ªèng Truy·ªÅn tin √Çm thanh An to√†n (AES-256 & RSA-2048)</h1>
        <div class="box full-width">
            <h2>B∆∞·ªõc 1: T·∫°o kh√≥a</h2>
            <p>Nh·∫•n n√∫t ƒë·ªÉ t·∫°o c√°c c·∫∑p kh√≥a RSA cho Alice (Ng∆∞·ªùi g·ª≠i) v√† Bob (Ng∆∞·ªùi nh·∫≠n).</p>
            <button id="generate-keys-btn">T·∫°o Kh√≥a cho c·∫£ Alice v√† Bob</button>
        </div>
        <div class="grid">
            <div class="box">
                <h2>Ph√≠a Ng∆∞·ªùi g·ª≠i (Alice)</h2>
                <label for="alice-public-key">Kh√≥a c√¥ng khai c·ªßa Alice:</label>
                <textarea id="alice-public-key" readonly></textarea>
                <label for="alice-private-key">Kh√≥a ri√™ng c·ªßa Alice:</label>
                <textarea id="alice-private-key" readonly></textarea>
                <hr>
                <label for="bob-public-key-input">Kh√≥a c√¥ng khai c·ªßa Bob (ƒë√£ t·ª± ƒëi·ªÅn):</label>
                <textarea id="bob-public-key-input"></textarea>
                <hr>
                <label>Ghi √¢m Tin nh·∫Øn tho·∫°i:</label>
                <div>
                    <button id="start-recording-btn" disabled>B·∫Øt ƒë·∫ßu Ghi √¢m</button>
                    <button id="stop-recording-btn" disabled>D·ª´ng Ghi √¢m</button>
                </div>
                <div id="recording-status">Tr·∫°ng th√°i: S·∫µn s√†ng. (Vui l√≤ng t·∫°o kh√≥a tr∆∞·ªõc)</div>
                <div id="audio-playback-container">
                    <label>Nghe l·∫°i b·∫£n ghi √¢m ƒë√£ g·ª≠i:</label>
                    <audio id="audio-playback" controls></audio>
                </div>
            </div>
            <div class="box">
                <h2>Ph√≠a Ng∆∞·ªùi nh·∫≠n (Bob)</h2>
                <label for="bob-public-key">Kh√≥a c√¥ng khai c·ªßa Bob:</label>
                <textarea id="bob-public-key" readonly></textarea>
                <label for="bob-private-key">Kh√≥a ri√™ng c·ªßa Bob:</label>
                <textarea id="bob-private-key" readonly></textarea>
            </div>
        </div>
        <div class="box full-width">
            <h2>K·∫øt qu·∫£ X·ª≠ l√Ω</h2>
            <button id="download-btn">T·∫£i xu·ªëng k·∫øt qu·∫£ (.zip)</button>
            <h3>G√≥i tin ƒë∆∞·ª£c g·ª≠i ƒëi (JSON):</h3>
            <pre id="packet-output">G√≥i tin s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y...</pre>
            <h3>Nh·∫≠t k√Ω x·ª≠ l√Ω (Log):</h3>
            <pre id="log-output">Nh·∫≠t k√Ω c√°c b∆∞·ªõc s·∫Ω xu·∫•t hi·ªán ·ªü ƒë√¢y...</pre>
        </div>
    </div>
    
    <script>
        // L·∫•y tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ HTML th√¥ng qua ID c·ªßa ch√∫ng ƒë·ªÉ c√≥ th·ªÉ ƒëi·ªÅu khi·ªÉn ch√∫ng b·∫±ng JS.
        const generateBtn = document.getElementById('generate-keys-btn');
        const startRecordingBtn = document.getElementById('start-recording-btn');
        const stopRecordingBtn = document.getElementById('stop-recording-btn');
        const downloadBtn = document.getElementById('download-btn');
        const statusDiv = document.getElementById('recording-status');
        const audioPlayback = document.getElementById('audio-playback');
        const audioPlaybackContainer = document.getElementById('audio-playback-container');
        const alicePubKeyTA = document.getElementById('alice-public-key');
        const alicePrivKeyTA = document.getElementById('alice-private-key');
        const bobPubKeyTA = document.getElementById('bob-public-key');
        const bobPrivKeyTA = document.getElementById('bob-private-key');
        const bobPubKeyInputTA = document.getElementById('bob-public-key-input');
        const packetOutput = document.getElementById('packet-output');
        const logOutput = document.getElementById('log-output');

        // Khai b√°o c√°c bi·∫øn s·∫Ω ƒë∆∞·ª£c s·ª≠ d·ª•ng cho vi·ªác ghi √¢m.
        let mediaRecorder; // ƒê·ªëi t∆∞·ª£ng MediaRecorder ƒë·ªÉ th·ª±c hi·ªán vi·ªác ghi √¢m.
        let audioChunks = []; // M·∫£ng ƒë·ªÉ l∆∞u c√°c ƒëo·∫°n d·ªØ li·ªáu √¢m thanh ƒë∆∞·ª£c ghi.

        // G√°n m·ªôt h√†m x·ª≠ l√Ω s·ª± ki·ªán 'click' cho n√∫t "T·∫°o Kh√≥a".
        generateBtn.addEventListener('click', async () => {
            logOutput.textContent = '‚è≥ ƒêang k·∫øt n·ªëi t·ªõi m√°y ch·ªß ƒë·ªÉ t·∫°o kh√≥a...'; // C·∫≠p nh·∫≠t tr·∫°ng th√°i
            generateBtn.disabled = true; // V√¥ hi·ªáu h√≥a n√∫t ƒë·ªÉ tr√°nh nh·∫•n nhi·ªÅu l·∫ßn
            // S·ª≠ d·ª•ng kh·ªëi try...catch ƒë·ªÉ b·∫Øt l·ªói n·∫øu c√≥ s·ª± c·ªë x·∫£y ra.
            try {
                // G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn API '/generate-all-keys' tr√™n server.
                const response = await fetch('/generate-all-keys', { method: 'POST' });
                // N·∫øu server tr·∫£ v·ªÅ l·ªói (v√≠ d·ª•: l·ªói 500), n√©m ra m·ªôt ngo·∫°i l·ªá ƒë·ªÉ kh·ªëi catch x·ª≠ l√Ω.
                if (!response.ok) throw new Error(`L·ªói HTTP ${response.status} t·ª´ m√°y ch·ªß.`);
                // Chuy·ªÉn ƒë·ªïi ph·∫£n h·ªìi t·ª´ server sang ƒë·ªëi t∆∞·ª£ng JSON.
                const data = await response.json();
                // ƒêi·ªÅn c√°c kh√≥a nh·∫≠n ƒë∆∞·ª£c v√†o c√°c √¥ textarea t∆∞∆°ng ·ª©ng tr√™n giao di·ªán.
                alicePubKeyTA.value = data.alice_public_key;
                alicePrivKeyTA.value = data.alice_private_key;
                bobPubKeyTA.value = data.bob_public_key;
                bobPrivKeyTA.value = data.bob_private_key;
                bobPubKeyInputTA.value = data.bob_public_key;
                logOutput.textContent = '‚úÖ ƒê√£ t·∫°o kh√≥a th√†nh c√¥ng! S·∫µn s√†ng ƒë·ªÉ ghi √¢m.';
                startRecordingBtn.disabled = false; // K√≠ch ho·∫°t n√∫t ghi √¢m.
            } catch (error) {
                // N·∫øu c√≥ l·ªói (v√≠ d·ª•: m·∫•t k·∫øt n·ªëi server), hi·ªÉn th·ªã th√¥ng b√°o l·ªói chi ti·∫øt cho ng∆∞·ªùi d√πng.
                console.error('L·ªói khi t·∫°o kh√≥a:', error);
                logOutput.innerHTML = `<span class="error-log">‚ùå L·ªñI K·∫æT N·ªêI KHI T·∫†O KH√ìA!<br><br>L√Ω do: ${error.message}<br><br>üëâ Vui l√≤ng ki·ªÉm tra l·∫°i xem √¥ m√£ Colab c√≥ c√≤n ƒëang ch·∫°y kh√¥ng v√† b·∫°n ƒëang d√πng ƒë√∫ng URL m·ªõi nh·∫•t.</span>`;
            } finally {
                // Kh·ªëi finally lu√¥n ƒë∆∞·ª£c th·ª±c thi d√π c√≥ l·ªói hay kh√¥ng.
                generateBtn.disabled = false; // K√≠ch ho·∫°t l·∫°i n√∫t "T·∫°o Kh√≥a".
            }
        });

        // G√°n s·ª± ki·ªán 'click' cho n√∫t "B·∫Øt ƒë·∫ßu Ghi √¢m".
        startRecordingBtn.addEventListener('click', async () => {
            try {
                // S·ª≠ d·ª•ng API c·ªßa tr√¨nh duy·ªát ƒë·ªÉ y√™u c·∫ßu quy·ªÅn truy c·∫≠p micro.
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                // Kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng MediaRecorder v·ªõi lu·ªìng √¢m thanh t·ª´ micro.
                mediaRecorder = new MediaRecorder(stream);
                // Reset l·∫°i c√°c bi·∫øn tr·∫°ng th√°i.
                audioChunks = [];
                audioPlaybackContainer.style.display = 'none';
                downloadBtn.style.display = 'none'; // ·∫®n n√∫t download.

                // S·ª± ki·ªán n√†y ƒë∆∞·ª£c k√≠ch ho·∫°t li√™n t·ª•c khi c√≥ m·ªôt ƒëo·∫°n d·ªØ li·ªáu √¢m thanh m·ªõi ƒë∆∞·ª£c ghi.
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data); // Th√™m ƒëo·∫°n d·ªØ li·ªáu v√†o m·∫£ng.
                };
                
                // S·ª± ki·ªán n√†y ƒë∆∞·ª£c k√≠ch ho·∫°t khi vi·ªác ghi √¢m d·ª´ng l·∫°i (khi g·ªçi mediaRecorder.stop()).
                mediaRecorder.onstop = async () => {
                    logOutput.textContent = '‚è≥ ƒê√£ d·ª´ng ghi √¢m. ƒêang g·ª≠i d·ªØ li·ªáu ƒë·ªÉ x·ª≠ l√Ω...';
                    packetOutput.textContent = 'ƒêang x·ª≠ l√Ω...';
                    // Gh√©p c√°c ƒëo·∫°n √¢m thanh l·∫°i th√†nh m·ªôt file ho√†n ch·ªânh (d∆∞·ªõi d·∫°ng ƒë·ªëi t∆∞·ª£ng Blob).
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    // T·∫°o m·ªôt URL t·∫°m th·ªùi cho file √¢m thanh ƒë·ªÉ c√≥ th·ªÉ ph√°t l·∫°i ngay tr√™n tr√¨nh duy·ªát.
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayback.src = audioUrl;
                    audioPlaybackContainer.style.display = 'block'; // Hi·ªÉn th·ªã tr√¨nh ph√°t audio.
                    // T·∫°o ƒë·ªëi t∆∞·ª£ng FormData ƒë·ªÉ ƒë√≥ng g√≥i c·∫£ file v√† d·ªØ li·ªáu vƒÉn b·∫£n g·ª≠i l√™n server.
                    const formData = new FormData();
                    formData.append('audio_data', audioBlob, 'recording.webm'); // Th√™m file √¢m thanh.
                    formData.append('alice_private_key', alicePrivKeyTA.value); // Th√™m c√°c kh√≥a.
                    formData.append('alice_public_key', alicePubKeyTA.value);
                    formData.append('bob_public_key', bobPubKeyInputTA.value);
                    formData.append('bob_private_key', bobPrivKeyTA.value);

                    // G·ª≠i y√™u c·∫ßu POST ch·ª©a file v√† c√°c kh√≥a ƒë·∫øn server ƒë·ªÉ x·ª≠ l√Ω.
                    try {
                        const response = await fetch('/process-message', { method: 'POST', body: formData });
                        if (!response.ok) throw new Error(`L·ªói HTTP ${response.status} t·ª´ m√°y ch·ªß.`);
                        const result = await response.json(); // Nh·∫≠n k·∫øt qu·∫£ x·ª≠ l√Ω t·ª´ server.
                        if (result.success) {
                            // T·∫°o m·ªôt b·∫£n sao c·ªßa packet ƒë·ªÉ hi·ªÉn th·ªã, kh√¥ng l√†m thay ƒë·ªïi packet g·ªëc
                            let displayPacket = { ...result.packet }; 
                            // N·∫øu chu·ªói cipher qu√° d√†i, r√∫t g·ªçn n√≥ ƒë·ªÉ hi·ªÉn th·ªã cho g·ªçn.
                            if (displayPacket.cipher && displayPacket.cipher.length > 250) {
                                displayPacket.cipher = displayPacket.cipher.substring(0, 250) + '... [ƒë√£ ƒë∆∞·ª£c r√∫t g·ªçn ƒë·ªÉ hi·ªÉn th·ªã]';
                            }
                            // Hi·ªÉn th·ªã packet ƒë√£ ƒë∆∞·ª£c t√πy ch·ªânh.
                            packetOutput.textContent = JSON.stringify(displayPacket, null, 2);
                            // Hi·ªÉn th·ªã n√∫t Download khi x·ª≠ l√Ω th√†nh c√¥ng.
                            downloadBtn.style.display = 'inline-block';
                        } else {
                            packetOutput.textContent = 'C√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω c·ªßa server.';
                        }
                        logOutput.textContent = result.log; // Hi·ªÉn th·ªã nh·∫≠t k√Ω x·ª≠ l√Ω.
                    } catch (error) {
                         // X·ª≠ l√Ω l·ªói k·∫øt n·ªëi khi g·ª≠i tin nh·∫Øn.
                         console.error('L·ªói khi x·ª≠ l√Ω tin nh·∫Øn:', error);
                         logOutput.innerHTML = `<span class="error-log">‚ùå L·ªñI K·∫æT N·ªêI KHI G·ª¨I TIN NH·∫ÆN!<br><br>L√Ω do: ${error.message}<br><br>üëâ Vui l√≤ng ki·ªÉm tra l·∫°i xem √¥ m√£ Colab c√≥ c√≤n ƒëang ch·∫°y kh√¥ng v√† b·∫°n ƒëang d√πng ƒë√∫ng URL m·ªõi nh·∫•t.</span>`;
                         packetOutput.textContent = 'G·ª≠i tin th·∫•t b·∫°i.';
                    }
                };
                // B·∫Øt ƒë·∫ßu qu√° tr√¨nh ghi √¢m.
                mediaRecorder.start();
                // C·∫≠p nh·∫≠t tr·∫°ng th√°i v√† c√°c n√∫t tr√™n giao di·ªán.
                statusDiv.textContent = "üî¥ ƒêang ghi √¢m...";
                startRecordingBtn.disabled = true;
                stopRecordingBtn.disabled = false;
            } catch (err) {
                // B·∫Øt l·ªói n·∫øu ng∆∞·ªùi d√πng kh√¥ng c·∫•p quy·ªÅn truy c·∫≠p micro.
                statusDiv.textContent = `L·ªói: ${err.message}. B·∫°n ƒë√£ cho ph√©p truy c·∫≠p micro ch∆∞a?`;
            }
        });

        // G√°n s·ª± ki·ªán 'click' cho n√∫t "D·ª´ng Ghi √¢m".
        stopRecordingBtn.addEventListener('click', () => {
            mediaRecorder.stop(); // L·ªánh n√†y s·∫Ω k√≠ch ho·∫°t s·ª± ki·ªán 'onstop' ƒë√£ ƒë·ªãnh nghƒ©a ·ªü tr√™n.
            // C·∫≠p nh·∫≠t l·∫°i tr·∫°ng th√°i giao di·ªán.
            statusDiv.textContent = "Tr·∫°ng th√°i: S·∫µn s√†ng ghi √¢m.";
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
        });
        
        // G√°n s·ª± ki·ªán 'click' cho n√∫t "T·∫£i xu·ªëng".
        downloadBtn.addEventListener('click', () => {
            // Chuy·ªÉn h∆∞·ªõng tr√¨nh duy·ªát ƒë·∫øn URL '/download-results' ƒë·ªÉ k√≠ch ho·∫°t vi·ªác t·∫£i file.
            window.location.href = '/download-results';
        });
    </script>
</body>
</html>
"""

# --- Backend Logic (Ph·∫ßn x·ª≠ l√Ω ph√≠a m√°y ch·ªß) ---

# H√†m ƒë·ªÉ t·∫°o m·ªôt c·∫∑p kh√≥a RSA (c√¥ng khai v√† b√≠ m·∫≠t) v·ªõi k√≠ch th∆∞·ªõc 2048 bits.
def generate_key_pair():
    # T·∫°o kh√≥a b√≠ m·∫≠t.
    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
    # Tr√≠ch xu·∫•t kh√≥a c√¥ng khai t·ª´ kh√≥a b√≠ m·∫≠t.
    public_key = private_key.public_key()
    # Chuy·ªÉn ƒë·ªïi kh√≥a b√≠ m·∫≠t sang ƒë·ªãnh d·∫°ng PEM (m·ªôt ƒë·ªãnh d·∫°ng vƒÉn b·∫£n).
    pem_private = private_key.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.PKCS8, encryption_algorithm=serialization.NoEncryption()).decode('utf-8')
    # Chuy·ªÉn ƒë·ªïi kh√≥a c√¥ng khai sang ƒë·ªãnh d·∫°ng PEM.
    pem_public = public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo).decode('utf-8')
    return pem_private, pem_public

# H√†m ƒë·ªÉ chuy·ªÉn ƒë·ªïi c√°c chu·ªói kh√≥a PEM (vƒÉn b·∫£n) tr·ªü l·∫°i th√†nh c√°c ƒë·ªëi t∆∞·ª£ng kh√≥a.
def deserialize_keys(pem_private_key, pem_public_key):
    # T·∫£i kh√≥a b√≠ m·∫≠t t·ª´ chu·ªói PEM n·∫øu c√≥.
    private_key = serialization.load_pem_private_key(pem_private_key.encode('utf-8'), password=None) if pem_private_key else None
    # T·∫£i kh√≥a c√¥ng khai t·ª´ chu·ªói PEM n·∫øu c√≥.
    public_key = serialization.load_pem_public_key(pem_public_key.encode('utf-8')) if pem_public_key else None
    return private_key, public_key

# ƒê·ªãnh nghƒ©a route (ƒë∆∞·ªùng d·∫´n) cho trang ch·ªß ('/').
@app.route('/')
def index():
    # Khi ng∆∞·ªùi d√πng truy c·∫≠p, tr·∫£ v·ªÅ giao di·ªán HTML.
    return render_template_string(HTML_TEMPLATE)

# ƒê·ªãnh nghƒ©a API endpoint ƒë·ªÉ t·∫°o kh√≥a. Ch·ªâ ch·∫•p nh·∫≠n ph∆∞∆°ng th·ª©c POST.
@app.route('/generate-all-keys', methods=['POST'])
def generate_all_keys_api():
    # T·∫°o c·∫∑p kh√≥a cho Alice.
    alice_private, alice_public = generate_key_pair()
    # T·∫°o c·∫∑p kh√≥a cho Bob.
    bob_private, bob_public = generate_key_pair()
    # Tr·∫£ v·ªÅ t·∫•t c·∫£ c√°c kh√≥a d∆∞·ªõi d·∫°ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON.
    return jsonify({
        "alice_public_key": alice_public, "alice_private_key": alice_private,
        "bob_public_key": bob_public, "bob_private_key": bob_private
    })

# ƒê·ªãnh nghƒ©a API endpoint ch√≠nh ƒë·ªÉ x·ª≠ l√Ω to√†n b·ªô qu√° tr√¨nh.
@app.route('/process-message', methods=['POST'])
def process_message_api():
    log = [] # T·∫°o m·ªôt danh s√°ch ƒë·ªÉ ghi l·∫°i nh·∫≠t k√Ω c√°c b∆∞·ªõc x·ª≠ l√Ω.
    global last_result_cache # Khai b√°o s·ª≠ d·ª•ng bi·∫øn t·∫°m to√†n c·ª•c.
    try:
        # L·∫•y file √¢m thanh v√† c√°c kh√≥a t·ª´ request g·ª≠i l√™n.
        audio_file = request.files.get('audio_data')
        if not audio_file: raise ValueError("Kh√¥ng nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu √¢m thanh.")
        alice_pem_private = request.form.get('alice_private_key')
        alice_pem_public = request.form.get('alice_public_key')
        bob_pem_public = request.form.get('bob_public_key')
        bob_pem_private = request.form.get('bob_private_key')
        audio_message_bytes = audio_file.read() # ƒê·ªçc n·ªôi dung file √¢m thanh.
        
        # M√¥ ph·ªèng ph√≠a ng∆∞·ªùi g·ª≠i (Alice)
        log.append("--- B·∫Øt ƒë·∫ßu ph√≠a Ng∆∞·ªùi g·ª≠i (Alice) ---")
        alice_private_key, _ = deserialize_keys(alice_pem_private, None)
        _, bob_public_key = deserialize_keys(None, bob_pem_public)
        aes_key = os.urandom(32) # 1. T·∫°o kh√≥a phi√™n AES-256 ng·∫´u nhi√™n.
        log.append("1. Alice: T·∫°o kh√≥a phi√™n AES-256 ng·∫´u nhi√™n.")
        encrypted_aes_key = bob_public_key.encrypt(aes_key, rsa_padding.OAEP(mgf=rsa_padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)) # 2. M√£ h√≥a kh√≥a AES b·∫±ng kh√≥a c√¥ng khai c·ªßa Bob.
        log.append("2. Alice: M√£ h√≥a kh√≥a AES b·∫±ng kh√≥a c√¥ng khai c·ªßa Bob.")
        iv = os.urandom(16) # T·∫°o vector kh·ªüi t·∫°o ng·∫´u nhi√™n.
        cipher_aes = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
        padder = PKCS7(algorithms.AES.block_size).padder() # Th√™m ƒë·ªám cho d·ªØ li·ªáu.
        padded_data = padder.update(audio_message_bytes) + padder.finalize()
        ciphertext = cipher_aes.encryptor().update(padded_data) # 3. M√£ h√≥a tin nh·∫Øn √¢m thanh b·∫±ng AES.
        log.append("3. Alice: M√£ h√≥a tin nh·∫Øn tho·∫°i b·∫±ng AES-256 CBC.")
        data_to_hash = iv + ciphertext
        hasher = hashes.Hash(hashes.SHA256())
        hasher.update(data_to_hash)
        final_hash = hasher.finalize() # 4. T·∫°o hash c·ªßa d·ªØ li·ªáu ƒë√£ m√£ h√≥a.
        log.append(f"4. Alice: T·∫°o hash SHA-256.")
        signature = alice_private_key.sign(final_hash, rsa_padding.PSS(mgf=rsa_padding.MGF1(hashes.SHA256()), salt_length=rsa_padding.PSS.MAX_LENGTH), hashes.SHA256()) # 5. K√Ω l√™n hash b·∫±ng kh√≥a ri√™ng c·ªßa Alice.
        log.append("5. Alice: D√πng kh√≥a ri√™ng c·ªßa m√¨nh ƒë·ªÉ k√Ω l√™n hash.")
        # 6. ƒê√≥ng g√≥i t·∫•t c·∫£ v√†o m·ªôt g√≥i tin JSON.
        packet = {"encrypted_aes_key": base64.b64encode(encrypted_aes_key).decode('utf-8'), "iv": base64.b64encode(iv).decode('utf-8'), "cipher": base64.b64encode(ciphertext).decode('utf-8'), "hash": final_hash.hex(), "sig": base64.b64encode(signature).decode('utf-8')}
        log.append("6. Alice: ƒê√≥ng g√≥i v√† g·ª≠i ƒëi.")
        
        # M√¥ ph·ªèng ph√≠a ng∆∞·ªùi nh·∫≠n (Bob)
        log.append("\n--- B·∫Øt ƒë·∫ßu ph√≠a Ng∆∞·ªùi nh·∫≠n (Bob) ---")
        _, alice_public_key = deserialize_keys(None, alice_pem_public)
        bob_private_key_obj, _ = deserialize_keys(bob_pem_private, None)
        decrypted_aes_key = bob_private_key_obj.decrypt(base64.b64decode(packet['encrypted_aes_key']), rsa_padding.OAEP(mgf=rsa_padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)) # 1. Gi·∫£i m√£ kh√≥a AES b·∫±ng kh√≥a ri√™ng c·ªßa Bob.
        log.append("1. Bob: D√πng kh√≥a ri√™ng gi·∫£i m√£ th√†nh c√¥ng kh√≥a AES.")
        log.append("2. Bob: B·∫Øt ƒë·∫ßu ki·ªÉm tra ch·ªØ k√Ω v√† t√≠nh to√†n v·∫πn...")
        recalculated_hash_obj = hashes.Hash(hashes.SHA256())
        recalculated_hash_obj.update(base64.b64decode(packet['iv']) + base64.b64decode(packet['cipher']))
        recalculated_hash = recalculated_hash_obj.finalize() # T√≠nh l·∫°i hash t·ª´ d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c.
        if recalculated_hash.hex() != packet['hash']: raise ValueError("L·ªói To√†n v·∫πn (Integrity Error)! Hash kh√¥ng kh·ªõp.") # So s√°nh hash.
        log.append("   - Ki·ªÉm tra Hash To√†n v·∫πn: OK.")
        alice_public_key.verify(base64.b64decode(packet['sig']), recalculated_hash, rsa_padding.PSS(mgf=rsa_padding.MGF1(hashes.SHA256()), salt_length=rsa_padding.PSS.MAX_LENGTH), hashes.SHA256()) # X√°c th·ª±c ch·ªØ k√Ω b·∫±ng kh√≥a c√¥ng khai c·ªßa Alice.
        log.append("   - X√°c th·ª±c Ch·ªØ k√Ω c·ªßa Alice: OK.")
        log.append("3. Bob: M·ªçi th·ª© h·ª£p l·ªá. Ti·∫øn h√†nh gi·∫£i m√£ tin nh·∫Øn tho·∫°i...")
        decryptor_cipher = Cipher(algorithms.AES(decrypted_aes_key), modes.CBC(base64.b64decode(packet['iv'])))
        unpadder = PKCS7(algorithms.AES.block_size).unpadder() # Lo·∫°i b·ªè ph·∫ßn ƒë·ªám.
        decrypted_padded_msg = decryptor_cipher.decryptor().update(base64.b64decode(packet['cipher']))
        decrypted_msg_bytes = unpadder.update(decrypted_padded_msg) + unpadder.finalize() # Gi·∫£i m√£ tin nh·∫Øn.
        log.append(f"   - Gi·∫£i m√£ th√†nh c√¥ng! Nh·∫≠n ƒë∆∞·ª£c {len(decrypted_msg_bytes)} bytes d·ªØ li·ªáu √¢m thanh.")
        
        # Hi·ªÉn th·ªã m·ªôt ph·∫ßn n·ªôi dung audio ƒë√£ gi·∫£i m√£ d∆∞·ªõi d·∫°ng Base64.
        audio_content_preview = base64.b64encode(decrypted_msg_bytes).decode('utf-8')
        log.append(f"   - N·ªôi dung (Base64 r√∫t g·ªçn): {audio_content_preview[:75]}...")

        log.append(f"\n‚úÖ TIN NH·∫ÆN THO·∫†I ƒê√É ƒê∆Ø·ª¢C GI·∫¢I M√É AN TO√ÄN! (G·ª≠i ACK)")
        
        # L∆∞u k·∫øt qu·∫£ v√†o bi·∫øn t·∫°m ƒë·ªÉ c√≥ th·ªÉ t·∫£i xu·ªëng.
        last_result_cache['packet'] = packet
        last_result_cache['audio_bytes'] = decrypted_msg_bytes
        
        # Tr·∫£ v·ªÅ k·∫øt qu·∫£ th√†nh c√¥ng.
        return jsonify({"success": True, "packet": packet, "log": "\n".join(log)})
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra trong qu√° tr√¨nh x·ª≠ l√Ω.
        log.append(f"\n‚ùå NACK: ƒê√É X·∫¢Y RA L·ªñI: {str(e)}")
        last_result_cache.clear() # X√≥a cache n·∫øu c√≥ l·ªói.
        return jsonify({"success": False, "log": "\n".join(log)})

# ƒê·ªãnh nghƒ©a API endpoint ƒë·ªÉ t·∫£i file zip.
@app.route('/download-results')
def download_results():
    # N·∫øu ch∆∞a c√≥ k·∫øt qu·∫£ n√†o ƒë∆∞·ª£c l∆∞u, b√°o l·ªói.
    if not last_result_cache:
        return "Kh√¥ng c√≥ k·∫øt qu·∫£ ƒë·ªÉ t·∫£i xu·ªëng. Vui l√≤ng x·ª≠ l√Ω m·ªôt tin nh·∫Øn th√†nh c√¥ng tr∆∞·ªõc.", 404

    # T·∫°o m·ªôt file ·∫£o trong b·ªô nh·ªõ RAM.
    memory_file = io.BytesIO()
    # M·ªü file zip v√† ghi v√†o file ·∫£o trong b·ªô nh·ªõ.
    with zipfile.ZipFile(memory_file, 'w', zipfile.ZIP_DEFLATED) as zf:
        # Ghi file packet.json v√†o zip.
        packet_json = json.dumps(last_result_cache.get('packet', {}), indent=2)
        zf.writestr('packet.json', packet_json)
        
        # Ghi file audio ƒë√£ gi·∫£i m√£ v√†o zip.
        audio_bytes = last_result_cache.get('audio_bytes', b'')
        zf.writestr('decrypted_audio.webm', audio_bytes)
    
    memory_file.seek(0) # ƒê∆∞a con tr·ªè v·ªÅ ƒë·∫ßu file ·∫£o.
    
    # Tr·∫£ v·ªÅ m·ªôt ƒë·ªëi t∆∞·ª£ng Response, b√°o cho tr√¨nh duy·ªát bi·∫øt ƒë√¢y l√† m·ªôt file c·∫ßn t·∫£i v·ªÅ.
    return Response(
        memory_file,
        mimetype='application/zip',
        headers={'Content-Disposition': 'attachment;filename=secure_message_files.zip'}
    )

# ==============================================================================
# PH·∫¶N 3: KH·ªûI CH·∫†Y ·ª®NG D·ª§NG
# ==============================================================================
print("üöÄ B∆∞·ªõc 3: Kh·ªüi ch·∫°y ·ª©ng d·ª•ng web...")
# Kh·ªüi ch·∫°y m·ªôt ƒë∆∞·ªùng h·∫ßm ngrok t·ªõi c·ªïng 5000 c·ªßa m√°y c·ª•c b·ªô.
public_url = ngrok.connect(5000)
# In ra URL c√¥ng khai ƒë·ªÉ ng∆∞·ªùi d√πng truy c·∫≠p.
print(f"üåç ·ª®ng d·ª•ng c·ªßa b·∫°n ƒëang ch·∫°y t·∫°i URL c√¥ng khai: {public_url}")

# Kh·ªüi ch·∫°y m√°y ch·ªß web Flask, l·∫Øng nghe c√°c k·∫øt n·ªëi tr√™n c·ªïng 5000.
app.run(port=5000)
